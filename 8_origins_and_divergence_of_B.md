# Origins and divergence of Bs

In this section we will try to ask:
 - How divergent are the B orthologs to the core genome? (approximated by sequence identity)
 - Whether the sequence identity to within-genome genes is higer than identity to orthologs in different species (solenopsis, longispinus)
 - Are the orthologs specific to a single core-genome chromosome?

The final outcome of this section is [this table](TODO) generated by [R_scripts/B_orthology.R](R_scripts/B_orthology.R) script, which is pulling all the results from all the searches together. Here are all the details how we generated all the intermediate files.

### Input data

The root for these analses will be `/data/ross/mealybugs/analyses/B_viburni_2020/7_B_divergence_and_origin`, but I will need more data from all over the place. Here is the list relative to: `/data/ross/mealybugs/analyses/`.

**P. viburni**
  - Genome: `B_viburni_2020/1_pacbio_assembly/8_freeze_v0/p.viburni.freeze.v0.fa`
  - Annotation: `B_viburni_2020/1_pacbio_assembly/8_freeze_v0/p.viburni.freeze.v0.braker.gff3`

**P. solenopsis**

- Genome: `phenacoccus_solenopsis/HiC_genome_Phenacoccus_solenopsis.fasta`
- Annotation: `phenacoccus_solenopsis/HiC_genome.gff3`

Note, when quering the reference, suffixes must be removed, e.g. `>PSOL00002-TA` needs to be trimmed to `PSOL00002`.

**P. longispinus**

- Genome: `pseudococcus_longispinus/8_freeze_v1/pseudococcus_longispinus.v1.assembly.fa`
- Annotation: `pseudococcus_longispinus/8_freeze_v1/pseudococcus_longispinus.v1.braker.gff3`

To make it easier, I linked the files above to three directories: `viburni`, `longispinus`, and `solenopsis`. The links are callec `genome.fa`, and `annotation.gff3` respectivelly.

#### Data preprocessing

Use gene annotation (probably `1_pacbio_assembly/7_braker/PVIB.BRAKER1/braker.gff3`) and scaffold assignments (`output/scaffolds.final.assignment.table.csv`)


```
python3 python_scripts/generate_B_genes_list.py > 7_B_divergence_and_origin/viburni/B_genes.tsv
```

For `viburni` and `longispinus` I need to get transcripts first, so I do it for all three to have it done consistently using gffread.

```
cd 7_B_divergence_and_origin
qsub -o logs -e logs -cwd -N gffread -V -pe smp64 1 -b yes 'gffread viburni/annotation.gff3 -g viburni/genome.fa -w viburni/transcripts.fa -y viburni/proteins.faa'
qsub -o logs -e logs -cwd -N gffread -V -pe smp64 1 -b yes 'gffread longispinus/annotation.gff3 -g longispinus/genome.fa -w longispinus/transcripts.fa -y longispinus/proteins.faa'
qsub -o logs -e logs -cwd -N gffread -V -pe smp64 1 -b yes 'gffread solenopsis/annotation.gff3 -g solenopsis/genome.fa -w solenopsis/transcripts.fa -y solenopsis/proteins.faa'
```

I will use this list to filter B genes out of `viburni/transcripts.fa`. Following script

```
python3 ../python_scripts/extracting_B_transcripts.py > viburni/B_transcripts.fa
```

### Orthology

All the following analyses will be based on some sort of orthology inference. I will do both nulceotide and amino acid reciprocal blast. Nucleotides give a better idea about nucleotide divergence and recent events, while amino acids will help us uncover more diverged homologs.

#### nt BLAST

The simple approach would be reciprocal blast of

1. within _P. viburni_
2. _P. viburni B_ + _P. solenopsis_
3. _P. viburni B_ + _P. longispinus_

The co-linearity should be based on aa reciprocal blast, the divergences should be calculated on nt reciprocal blast. I will start with nt, the `aa`.

1. within _P. viburni_

```
GENES=viburni/transcripts.fa
makeblastdb -in $GENES -dbtype nucl

mkdir -p blastout
qsub -o logs -e logs -cwd -N selfblast -V -pe smp64 16 -b yes 'blastn -query '"$GENES"' -db '"$GENES"' -evalue 1e-10 -outfmt "6 std qlen slen" -num_threads 16 > blastout/viburni_all_vs_all.blast'
```

2. _P. viburni B_ + _P. solenopsis_

```
GENES=solenopsis/solenopsis_and_B_viburni_transcripts.fa
cat viburni/B_transcripts.fa > $GENES
cat solenopsis/transcripts.fa >> $GENES
makeblastdb -in $GENES -dbtype nucl
qsub -o logs -e logs -cwd -N selfblast -V -pe smp64 16 -b yes 'blastn -query '"$GENES"' -db '"$GENES"' -evalue 1e-10 -outfmt "6 std qlen slen" -num_threads 16 > blastout/solenopsis_and_B_viburni_all_vs_all.blast'
```

3. _P. viburni B_ + _P. longispinus_

```
GENES=longispinus/longispinus_and_B_viburni_transcripts.fa
cat viburni/B_transcripts.fa > $GENES
cat longispinus/transcripts.fa >> $GENES
makeblastdb -in $GENES -dbtype nucl
qsub -o logs -e logs -cwd -N selfblast -V -pe smp64 16 -b yes 'blastn -query '"$GENES"' -db '"$GENES"' -evalue 1e-10 -outfmt "6 std qlen slen" -num_threads 16 > blastout/longispinus_and_B_viburni_all_vs_all.blast'
```

And using `python_scripts/reciprocal_blast.py` (originally written for Hodson et al. 2021, available [here](https://raw.githubusercontent.com/RossLab/Bradysia-GRCs/master/scripts/genome_wide_paralogy/reciprocal_blast.py)) get the reciprocal hits out of all-to-all blast.

```
python3 ../python_scripts/reciprocal_blast.py blastout/viburni_all_vs_all.blast blastout/Within_viburni_reciprocal
python3 ../python_scripts/reciprocal_blast.py blastout/solenopsis_and_B_viburni_all_vs_all.blast blastout/solenopsis_and_B_viburni_reciprocal
python3 ../python_scripts/reciprocal_blast.py blastout/longispinus_and_B_viburni_all_vs_all.blast blastout/longispinus_and_B_viburni_reciprocal
```

and now I will process the table in `R`.

```{R}
B_genes <- read.table('viburni/B_genes.tsv', header = F, col.names = c('gene', 'asn'))

load_reciprocal <- function(filename){
  reciprocal <- read.table(filename, header = T)

  reciprocal$gene1 <- sapply(strsplit(reciprocal$gene1, '.', fixed = TRUE), function(x){ x[1] })
  reciprocal$gene2 <- sapply(strsplit(reciprocal$gene2, '.', fixed = TRUE), function(x){ x[1] })

  reciprocal$gene1_asn <- 'A'
  reciprocal$gene2_asn <- 'A'

  reciprocal$gene1_asn[reciprocal$gene1 %in% B_genes[B_genes[, 'asn'] == 'B', 'gene']] <- 'B'
  reciprocal$gene1_asn[reciprocal$gene1 %in% B_genes[B_genes[, 'asn'] == 'Bc', 'gene']] <- 'Bc'

  reciprocal$gene2_asn[reciprocal$gene2 %in% B_genes[B_genes[, 'asn'] == 'B', 'gene']] <- 'B'
  reciprocal$gene2_asn[reciprocal$gene2 %in% B_genes[B_genes[, 'asn'] == 'Bc', 'gene']] <- 'Bc'

  return(reciprocal)
}

viburni_reciprocal <- load_reciprocal('blastout/Within_viburni_reciprocal_OG_pairs.tsv')

viburni_reciprocal_no_A <- viburni_reciprocal[viburni_reciprocal$gene1_asn != 'A' | viburni_reciprocal$gene2_asn != 'A', ]

viburni_BA_homologs <- viburni_reciprocal_no_A[viburni_reciprocal_no_A$gene1_asn == 'A' | viburni_reciprocal_no_A$gene2_asn == 'A', ]

is_gene1_the_B_gene <- ('B' == viburni_BA_homologs$gene1_asn | 'Bc' == viburni_BA_homologs$gene1_asn) # logcal vector of T/F if it's first or the second in the pair
viburni_BA_homologs$B_copy <- NA
viburni_BA_homologs$B_copy[is_gene1_the_B_gene] <- viburni_BA_homologs$gene1[is_gene1_the_B_gene]
viburni_BA_homologs$B_copy[!is_gene1_the_B_gene] <- viburni_BA_homologs$gene2[!is_gene1_the_B_gene]

write.table(viburni_BA_homologs, '../output/B_inter_genome_homology.tsv', row.names = F, sep = '\t', quote = F)

table(viburni_BA_homologs$B_copy)

nrow(viburni_BA_homologs[viburni_BA_homologs$gene1_asn == 'B' | viburni_BA_homologs$gene2_asn == 'B', ])
```

33 / 324 B-linked genes have a paralog within the viburni core genome: 6 / 204 among genes on B scaffolds, and 27 / 120 among genes on Bc scaffolds. Of course, these are homologs between sequences assigned to the core or accessory genomes and the majority of B genes (146) are on a scaffold that is present BOTH in the core genome and B (scaffold_360). Taking this in account the real numbers would be 152 / 204 and 27 / 120 respectivelly.

For 0 / 8 of B and Bc genes we found an orthologs in longispinus and 0 / 2 in solenopsis. For the few that were shared we manually checked that the similarity is always viburni > longispinus > solenopsis.

My interpretation is that the B chromosomes occasionally harbour both copies and translocated genes and all of this traffic must happened after the viburni - longispinus.

### Hits to other species

Blast all B genes against ncbi (2020/02), and use diamond to search homology against uniprot (2019/08),

```bash
qsub -o logs -e logs -cwd -N diamond -V -pe smp64 16 -b yes 'diamond blastx --query viburni/B_transcripts.fa --max-target-seqs 5 --sensitive --threads 16 --db /ceph/software/databases/uniprot_2018_04/full/reference_proteomes.dmnd --evalue 1e-25 --tmpdir /scratch/kjaron/ --outfmt 6 --out /scratch/kjaron/B_genes.diamond.out && rsync /scratch/kjaron/B_genes.diamond.out blastout'

qsub -o logs -e logs -cwd -N blastn -V -pe smp64 16 -b yes 'blastn -task megablast -query viburni/B_transcripts.fa -db /ceph/software/databases/ncbi/nt -outfmt "6 qseqid staxids bitscore std" -max_target_seqs 10 -max_hsps 1 -num_threads 32 -evalue 1e-25 -out /scratch/kjaron/B_genes.blast.out && rsync /scratch/kjaron/B_genes.blast.out blastout'
```

I will hijack the blobtools2 workflow in asiggning taxons to hits

```bash
conda activate blobtools
cp /ceph/software/databases/uniprot_2018_04/full/reference_proteomes.taxid_map .
qsub -o logs -e logs -cwd -N taxify -V -pe smp64 1 -b yes '/ceph/software/blobtools/blobtools taxify -f blastout/B_genes.diamond.out -m reference_proteomes.taxid_map -s 0 -t 2'
```

```bash
grep "scientific name" data/names.dmp | cut -f 1,2 -d \| > data/id2names.tsv
```

To annotate the blast/diomant outputfiles using scientific names from the dictionary, we will use following script (saved as `python_scripts/assigning_taxa.py`)

```bash
python3 ../python_scripts/assigning_taxa.py blastout/B_genes.blast.out > B_genes.blast_taxa_overview.tsv
python3 ../python_scripts/assigning_taxa.py blastout/B_genes.diamond.taxified.out > B_genes.diamond_taxa_overview.tsv
```

and checking which of these hits do NOT have a hit within viburni!

```R
diamond <- read.table('output/B_genes.diamond_taxa_overview.tsv', sep = '\t', header = T)
reciprocal_blast <- read.table('output/B_inter_genome_homology.tsv', sep = '\t', header = T)

diamond[diamond$scf == 'scaffold_360', ]

B_with_no_core_homology[!grepl("virus", B_with_no_core_homology$diamond_hits), ]
nrow(diamond[diamond$gene %in% reciprocal_blast$B_copy,])

Hemiptera <- B_with_no_core_homology[(grepl("citri", B_with_no_core_homology$diamond_hits) | grepl("pisum", B_with_no_core_homology$diamond_hits)), ]
nrow(diamond[diamond$gene %in% Hemiptera$gene,])


B_with_no_core_homology <- diamond[!diamond$gene %in% reciprocal_blast$B_copy,]



```

7 B-genes have a homolog in the rest of the genome and an arthropod hit.


diamond[diamond$gene %in% reciprocal_blast$B_copy,]


### Exploration of the chromosomal origin

Solenopsis has a really sweet chr. lvl assembly, which allows to search for colinearity between B scaffolds and individual chromosomes

#### nt proxy

This is just a quick peek using nt reciprocal blast. I saved content of `solenopsis_orthologs$gene1` vector in a file `solenopsis/B_orthologs.tsv` and grepped it out of solenopsis annotation

```
grep "gene" solenopsis/annotation.gff3 | grep -f solenopsis/B_orthologs.tsv
```

And it turns out that out of 11 orthologs, 2 come from chr2, 2 from chr3, 3 from chr5, 4 from chr4.

This would be better done using colinear blocks and inidividual genes might be a bit missleading when it comes to chromosomal origin (let's face it, some of them jump a bit around). Yet, given this peek, I would not expect a clear single-chromosome origin of Bs.
